<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SpringBoot on Phantom</title>
    <link>http://localhost:1313/categories/springboot/</link>
    <description>Recent content in SpringBoot on Phantom</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 18 Dec 2019 16:47:50 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/springboot/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SpringBoot集成kafka实现生产消费</title>
      <link>http://localhost:1313/posts/springboot-kafka/</link>
      <pubDate>Wed, 18 Dec 2019 16:47:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/springboot-kafka/</guid>
      <description>场景 链接到标题 对接方需要使用kafka作为消息中间件来交互数据，需要提供一个消费接口消费对方柜面系统前端实时更新的数据，结合我们平台本身的批处理定时任务，模型跑完数据需要生产到另一个主题供对接方消费。&#xA;依赖引入 链接到标题 pom.xml 引入依赖 注意kafka版本&#xA;springboot配置文件里加入kafka配置&#xA;注意如果关闭自动提交需要如图listener中配置 否则在使用Acknowledgment自动提交时会报参数异常，但是在低版本的kafka没有这个问题。&#xA;一些kafka配置 仅供参考&#xA;#kafka配置信息 kafka: producer: bootstrap-servers:0.0.0.0:9092 batch-size: 16785 #一次最多发送数据量 retries: 1 #发送失败后的重复发送次数 buffer-memory: 33554432 #32M批处理缓冲区 linger: 1 consumer: group-id: mms_test bootstrap-servers: 0.0.0.0:9092 auto-offset-reset: latest #最早未被消费的offset earliest enable-auto-commit: false #是否开启自动提交 max-poll-records: 3100 #批量消费一次最大拉取的数据量 auto-commit-interval: 1000 #自动提交的间隔时间 session-timeout: 20000 #连接超时时间 max-poll-interval: 15000 #手动提交设置与poll的心跳数,如果消息队列中没有消息，等待毫秒后，调用poll()方法。如果队列中有消息，立即消费消息，每次消费的消息的多少可以通过max.poll.records配置。 max-partition-fetch-bytes: 15728640 #设置拉取数据的大小,15M listener: ack-mode: manual # 配置参数 手动提交偏移量 batch-listener: true #是否开启批量消费，true表示批量消费 concurrency: 5 #设置消费的线程数 poll-timeout: 1500 消费者 链接到标题 核心注解</description>
    </item>
    <item>
      <title>SpringBoot上传踩坑-linux临时文件</title>
      <link>http://localhost:1313/posts/springbootuploadtmp/</link>
      <pubDate>Tue, 08 Oct 2019 15:55:23 +0000</pubDate>
      <guid>http://localhost:1313/posts/springbootuploadtmp/</guid>
      <description>今天生产上传文件的功能无法使用，定位问题，springboot项目日志输出IO异常，如下图&#xA;观察异常信息，明显是指在linux服务器下/tmp下的一个临时文件路径不可用。&#xA;cd到tmp路径下查询真的没有这个路径，查阅资料后发现，在启动时会自动指定一个默认的临时上传路径，但是linux的/tmp下的临时文件如果一定时间不使用的话会被清理掉，没有这个目录在上传新文件的时候就会报错。&#xA;这个报错也是在十一国庆假期后发现的，在开发测试中因为经常重启所以可能这个问题没有暴露出来，引以为戒。&#xA;重启项目只是治标不治本的方法，所以我们在启动类中指定临时文件的路径，这样我们在服务器上创建一个固定的位置就不用但是会被清理掉了。&#xA;springboot指定上传临时路径 链接到标题 在你的springboot项目的启动类中添加如下代码：&#xA;@Bean public MultipartConfigElement multipartConfigElement() { MultipartConfigFactory factory = new MultipartConfigFactory(); // 指定服务器上的固定路径 factory.setLocation(&amp;#34;/app/mms/upload&amp;#34;); return factory.createMultipartConfig(); } 配置完成后就不用担心临时文件路径的问题了！</description>
    </item>
    <item>
      <title>SpringBoot之事务踩坑</title>
      <link>http://localhost:1313/posts/springboottransactional/</link>
      <pubDate>Thu, 08 Aug 2019 14:07:08 +0000</pubDate>
      <guid>http://localhost:1313/posts/springboottransactional/</guid>
      <description>在项目多使用了多数据源(因为可能会有odps等多数据源的查询需求)，并且是手动配置数据源的方式，在配置了一段时间后使用数据源和切换都没有问题，但是在开发业务的时候发现在一个插入操作里，分别要向4张数据表中记录数据，最后请求服务，通过服务的响应来决定数据是否回滚，因为没有异常操作，所以我使用手动回滚的方式在if判断里回滚数据，结果尴尬的发现事务不好用了。。。！&#xA;因为使用的是声明式事务，也就是在service的实现类上添加@Transactional注解的实现方式，这里需要注意几个使用时容易采坑的点&#xA;注意点 链接到标题 1.一般在controller调用service中的方法，并且不要嵌套调用，因为实现原理是代理注解的类，必须由spring管理才能生效，类的内部调用没有使用注入对象所以spring不会拦截异常，事务不会开启。 2.@Transactional写在类上或者方法上。&#xA;3.Aop声明事务是只捕获unchecked exception也就是默认对RuntimeException()异常或是其子类进行事务回滚，如果想在抛出Exception捕获需要添加注解属性&#xA;@Transactional(rollbackFor = Exception.class) 或者在try catch块中添加手动回滚的代码(侵入性比较大)&#xA;TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 4.数据库需要支持事务、比如用的是mysql就必须使用innoDB的引擎，否则不支持事务。&#xA;问题跟踪 链接到标题 在确定自己没有犯以上的错误后，事务还是无法回滚。。。最后决定开始debug跟一下源码发现，在拿到数据连接对象执行回滚之前要判断transactionInfo这个对象是否为空，结果发现，虽然事务管理器是开启了，但是数据库连接的事务对象是null..&#xA;也就是说，在数据源初始化配置的时候开启的事务管理器和项目中使用的数据源连接根本就没有绑定上&#xA;再看一下我多数据源在实例化事务管理器的代码：&#xA;这里的test1DataSoource是我在实例化动态数据源配置对象的时候的默认数据源、也就是主数据源。&#xA;实例化动态数据源对象配置：&#xA;问题找到了，问题就出现在我在事务管理器初始化时用的数据源不是我配置的动态数据源的DataSource对象dynamicDataSource，而是test1DataSource。。。&#xA;将实例化事务管理器的声明参数修改成dynamicDataSource、试验回滚方法成功！</description>
    </item>
    <item>
      <title>SpringBoot整合Quartz(三)</title>
      <link>http://localhost:1313/posts/springbootquartz3/</link>
      <pubDate>Thu, 04 Jul 2019 15:58:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/springbootquartz3/</guid>
      <description>MyJobFactory.java 链接到标题 由于业务需要在执行时调用业务逻辑，所以在job类的执行时就必须注入，在开始写配置的时候，执行注入的mapper接口的方法时报了空指针异常。&#xA;查了资料发现是由于quartz的Job默认是由quartz创建的不受spring管理，所以无法注入。所以使用继承AdaptableJobFactory的自定义工厂来创建定时器。&#xA;/** * @title: 自定义Job工厂 * 解决job由quartz创建spring无法注入的问题 * @author zhangxueshan * @date:2019年6月20日 下午4:11:43 */ @Component public class MyJobFactory extends AdaptableJobFactory { @Autowired private AutowireCapableBeanFactory capableBeanFactory; protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception { Object jobInstance = super.createJobInstance(bundle); capableBeanFactory.autowireBean(jobInstance); return jobInstance; } } QuartzJob.java 链接到标题 最后就是job类了，在里面写好要执行的业务逻辑，其实就是调用service层的方法。&#xA;/** * @title:定时任务类 * @author zhangxueshan * @date:2019年5月16日 下午5:15:23 */ @Service public class QuartzJob implements Job{ private static final Logger logger = LoggerFactory.</description>
    </item>
    <item>
      <title>SpringBoot整合Quartz(二)</title>
      <link>http://localhost:1313/posts/springbootquartz2/</link>
      <pubDate>Thu, 04 Jul 2019 15:32:11 +0000</pubDate>
      <guid>http://localhost:1313/posts/springbootquartz2/</guid>
      <description>接上一篇文章，本文中展示在springboot项目中根据特定需求配置quartz定时任务。&#xA;POM文件中添加依赖 链接到标题 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 配置类 StartQuartzJobListener.java 链接到标题 首先需要有个配置类来初始化quartz，&#xA;QuartzManager 是 quartz的具体管理类。&#xA;MyJobFactory 是一个自定义的Job工厂类，用来解决默认的Job类不支持spring注入。 TimeTaskPlanMapper 是具体的业务Mapper接口用来查询数据库中的配置。&#xA;@Configuration public class StartQuartzJobListener implements ApplicationListener&amp;lt;ContextRefreshedEvent&amp;gt; { private static final Logger logger = LoggerFactory.getLogger(StartQuartzJobListener.class); /* quartz */ @Autowired private QuartzManager quartzManager; @Autowired private MyJobFactory myJobFactory; @Resource private TimeTaskPlanMapper ttpm; /** * 初始启动quartz */ @Override public void onApplicationEvent(ContextRefreshedEvent event) { try { logger.debug(&amp;#34;查询配置表中启动的定时任务集合&amp;#34;); // 从数据库查询定时任务列表 List&amp;lt;UpperCaseMap&amp;gt; tasklist = ttpm.getTimeTasks(); for (UpperCaseMap upperCaseMap : tasklist) { int task_plan_code = (int) upperCaseMap.</description>
    </item>
    <item>
      <title>SpringBoot整合Quartz(一)</title>
      <link>http://localhost:1313/posts/springbootquartz/</link>
      <pubDate>Thu, 04 Jul 2019 14:40:10 +0000</pubDate>
      <guid>http://localhost:1313/posts/springbootquartz/</guid>
      <description>在做springboot的项目中有一个特殊需求，前端动态添加定时任务，动态停启定时任务，任务内容是通过动态新增的数据来发起post请求请求python对外接口。&#xA;首先想到使用SpringBoot自带的注解@Scheduled来实现定时，通过相关注解可以配置同步、异步任务。&#xA;后来发现对这种动态的支持不是很好，所以改用quartz来实现。&#xA;Quartz 简单介绍 链接到标题 Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。 Quartz 可以与 J2EE 与 J2SE 应用程序相结合也可以单独使用。 Quartz 允许程序开发人员根据时间的间隔来调度作业。 Quartz 实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。&#xA;Quartz 核心概念 链接到标题 我们需要明白 Quartz 的几个核心概念，这样理解起 Quartz 的原理就会变得简单了。&#xA;1.Job 表示一个工作，要执行的具体内容。此接口中只有一个方法，如下：&#xA;void execute(JobExecutionContext context) 2.JobDetail 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。&#xA;3.Trigger 代表一个调度参数的配置，什么时候去调。&#xA;4.Scheduler 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。 当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。&#xA;在Springboot中整合quartz非常简单，在高版本的springboot中自带quartz支持和默认配置。&#xA;Quartz 触发器 链接到标题 在这里简单说一下quartz的触发器，在项目中需求定时要求输入开始时间，结束时间，时间间隔和单位，分析之后选择使用日历触发器来实现。&#xA;例举quartz的触发器：&#xA;SimpleTrigger 链接到标题 简单触发器，适用于短期内的循环定时任务，定义一个开始时间到达开始时间就执行定时，进行循环。 因为需求原因需要区别日期，例如当月1日10点执行，下个月1日10点在触发。简单触发器就不支持，直接间隔年月日这种类型。&#xA;CronTrigger 链接到标题 cron表达式的触发器，这种触发器支持基于日历来定时，不过需要生成cron表达式，在前端集成插件或者后台判断生成cron都比较重，我们的功能要求的比较简单所以没采用cron的触发器。&#xA;CalendarIntervalTrigger 链接到标题 日历触发器，类似于SimpleTrigger，指定从某一个时间开始，以一定的时间间隔执行的任务。 但是不同的是SimpleTrigger指定的时间间隔为毫秒，没办法指定每隔一个月执行一次（每月的时间间隔不是固定值），而CalendarIntervalTrigger支持的间隔单位有秒，分钟，小时，天，月，年，星期。</description>
    </item>
    <item>
      <title>SpringBoot之多数据源配置</title>
      <link>http://localhost:1313/posts/springbootdatasource/</link>
      <pubDate>Wed, 03 Jul 2019 14:14:44 +0000</pubDate>
      <guid>http://localhost:1313/posts/springbootdatasource/</guid>
      <description>应用背景 链接到标题 因为项目需求导致需要连接多个数据源，可能为Mysql及其他源，所以需要在项目中配置多数据源，来达到执行不同业务的时候切换不同的数据源。&#xA;参考了很多资料，结合应用本身，决定使用配置类来配置动态数据源，通过配置AOP在service层上配置切点来控制数据源的切换。&#xA;1.动态数据源 DynamicDataSource.java 链接到标题 首先定义一个动态数据源类&#xA;public class DynamicDataSource extends AbstractRoutingDataSource { @Override protected Object determineCurrentLookupKey() { DataSourceType.DataBaseType dataBaseType = DataSourceType.getDataBaseType(); return dataBaseType; } } 2.切换数据源线程类 DataSourceType.java 链接到标题 public class DataSourceType { public enum DataBaseType { DATA1, DATA2 } // 使用ThreadLocal保证线程安全 private static final ThreadLocal&amp;lt;DataBaseType&amp;gt; TYPE = new ThreadLocal&amp;lt;DataBaseType&amp;gt;(); // 往当前线程里设置数据源类型 public static void setDataBaseType(DataBaseType dataBaseType) { if (dataBaseType == null) { throw new NullPointerException(); } System.err.println(&amp;#34;[将当前数据源改为]：&amp;#34; + dataBaseType); TYPE.</description>
    </item>
  </channel>
</rss>
